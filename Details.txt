
==== String Functions ====

str.isalnum()
str.isalpha()
str.isdigit()
str.islower()
str.isupper()

srt.ljust(width, "-")
str.cjust(width, "-")
str.rjust(width, "-")



==== List Functions ====





==== Set Functions ====

s = set()
s.add([element])
s.remove([element])
s.discard([element])

Union - Belongs to both the set and iterable
- setA.union(setB [or any iterable])
- setA | setB

Intersection - Common between the set and the iterable
- setA.intersection(setB [or any iterable])
- setA & setB

Difference - Present in setA but not in setB
- setA.difference(setB)
- setA - setB

Symmetric Difference - Present in either setA or setB but not in both
- setA.symmetric_difference(setB [or any iterable])
- setA ^ setB

Union Update
- .update() or |=
- Update the set by adding elements from an iterable/another set

Intersection Update
- .intersection_update() or &=
- Update the set by keeping only the elements found in it and an iterable/another set.

Difference Update
- .difference_update() or -=
- Update the set by removing elements found in an iterable/another set.

Symmetric Difference Update
- .symmetric_difference_update() or ^=
- Update the set by only keeping the elements found in either set, but not in both.



==== Complex Numbers ====

complex(arg) - it will create a complex number from the given arg
arg can be in the form of complex number "1+2j" or polar cordinates (1.0, 0.0)

complex_number.real = it will give real part
complex_number.imag = it will give imaginery part

cmath.phase(complex_number) - it will give phase angle of a complex number
arg(complex_number) - it will give modulus of a complex number



==== Itertools ====

1. itertools.product()
This tool computes the cartesian product of input iterables.
It is equivalent to nested for-loops.
For example, product(A, B) returns the same as ((x,y) for x in A for y in B).

2. itertools.permutations(iterable [, R])
This tool returns successive R length permutations of elements in an iterable.
If R is not specified or is None, then R defaults to the length of the iterable, and all possible full length permutations are generated.
Permutations are printed in a lexicographic sorted order. So, if the input iterable is sorted, the permutation tuples will be produced in a sorted order.

3. itertools.combinations(iterable, R)
This tool returns the R length subsequences of elements from the input iterable.
Combinations are emitted in lexicographic sorted order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.

4. itertools.combinations_with_replacement(iterable, R)
This tool returns R length subsequences of elements from the input iterable allowing individual elements to be repeated more than once.
Combinations are emitted in lexicographic sorted order. So, if the input iterable is sorted, the combination tuples will be produced in sorted order.

